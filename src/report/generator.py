"""Report generation for repository reviews."""

from datetime import datetime
from typing import Any, Dict, List

from ..core.config import get_config
from ..core.logging_ import get_logger
from ..github import Repository

logger = get_logger(__name__)

config = get_config()


class ReportGenerator:
    """Generates markdown reports for repository reviews."""

    def generate_review_report(
        self, repo: Repository, review_result: Dict[str, Any]
    ) -> str:
        """Generate a comprehensive review report."""
        scores = review_result.get("quality_scores", {})
        stuck_areas = review_result.get("stuck_areas", [])
        next_steps = review_result.get("next_steps", [])
        issues = review_result.get("issues_found", [])
        recommendations = review_result.get("recommendations", [])
        todos = review_result.get("todos", [])

        report = f"""# Repository Status Report: {repo.full_name}

Generated: {datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")}

## Overview

| Field | Value |
|-------|-------|
| **Repository** | [{repo.full_name}]({repo.html_url}) |
| **Description** | {repo.description or "No description"} |
| **Language** | {repo.language or "Unknown"} |
| **Private** | {'Yes' if repo.is_private else 'No'} |
| **Archived** | {'Yes' if repo.is_archived else 'No'} |
| **Stars** | {repo.stargazers_count} |
| **Forks** | {repo.forks_count} |
| **Open Issues** | {repo.open_issues_count} |

## Quality Scores

| Category | Score |
|----------|-------|
| **Overall** | {self._score_bar(scores.get('overall', 0))} |
| Code Quality | {self._score_bar(scores.get('code_quality', 0))} |
| Documentation | {self._score_bar(scores.get('documentation', 0))} |
| Structure | {self._score_bar(scores.get('structure', 0))} |
| Testing | {self._score_bar(scores.get('testing', 0))} |

## Summary

{review_result.get('summary', 'No summary available.')}

## Stuck Areas

{self._format_list(stuck_areas) if stuck_areas else 'No stuck areas identified.'}

## Next Steps

{self._format_numbered_list(next_steps) if next_steps else 'No specific next steps recommended.'}

## Issues Found

{self._format_issues(issues) if issues else 'No critical issues found.'}

## TODOs/FIXMEs

{self._format_todos(todos) if todos else 'No TODO or FIXME comments found.'}

## Recommendations

{self._format_numbered_list(recommendations) if recommendations else 'No additional recommendations.'}

## Files Analyzed

- Total Files: {review_result.get('analyzed_files', 0)}
- Total Lines of Code: {review_result.get('total_lines', 0)}

---

*This report was automatically generated by Project Agent.*
"""

        return report

    def generate_summary_dashboard(
        self, review_results: List[Dict[str, Any]]
    ) -> str:
        """Generate a summary dashboard for multiple repositories."""
        total = len(review_results)
        completed = sum(1 for r in review_results if r.get("status") == "completed")
        failed = total - completed

        avg_scores = {
            "overall": 0,
            "code_quality": 0,
            "documentation": 0,
            "structure": 0,
            "testing": 0,
        }

        for result in review_results:
            if result.get("status") == "completed":
                scores = result.get("quality_scores", {})
                for key in avg_scores:
                    avg_scores[key] += scores.get(key, 0)

        for key in avg_scores:
            avg_scores[key] = avg_scores[key] / max(completed, 1)

        report = f"""# Project Agent - Repository Review Summary

Generated: {datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")}

## Statistics

| Metric | Value |
|--------|-------|
| Total Repositories | {total} |
| Completed Reviews | {completed} |
| Failed Reviews | {failed} |
| Success Rate | {(completed / total * 100) if total > 0 else 0:.1f}% |

## Average Quality Scores

| Category | Score |
|----------|-------|
| **Overall** | {self._score_bar(avg_scores['overall'])} |
| Code Quality | {self._score_bar(avg_scores['code_quality'])} |
| Documentation | {self._score_bar(avg_scores['documentation'])} |
| Structure | {self._score_bar(avg_scores['structure'])} |
| Testing | {self._score_bar(avg_scores['testing'])} |

## Repository Details

| Repository | Status | Overall Score | Stuck Areas | Next Steps |
|------------|--------|---------------|-------------|------------|
"""

        for result in review_results:
            repo_name = result.get("repository_name", "Unknown")
            status = result.get("status", "unknown")
            score = result.get("quality_scores", {}).get("overall", 0)
            stuck = len(result.get("stuck_areas", []))
            next_steps_count = len(result.get("next_steps", []))

            status_emoji = "OK" if status == "completed" else "FAIL"
            report += f"| {repo_name} | {status_emoji} | {score:.0f}/100 | {stuck} | {next_steps_count} |\n"

        report += """
---

*This dashboard was automatically generated by Project Agent.*
"""

        return report

    def _score_bar(self, score: float, length: int = 20) -> str:
        """Create a visual score bar."""
        filled = int(score / 100 * length)
        bar = "â–ˆ" * filled + "â–‘" * (length - filled)
        return f"`{bar}` {score:.0f}%"

    def _format_list(self, items: List[str]) -> str:
        """Format a list with bullet points."""
        if not items:
            return "None"
        return "\n".join(f"- {item}" for item in items)

    def _format_numbered_list(self, items: List[str]) -> str:
        """Format a numbered list."""
        if not items:
            return "None"
        return "\n".join(f"{i+1}. {item}" for i, item in enumerate(items))

    def _format_issues(self, issues: List[Dict[str, Any]]) -> str:
        """Format issues as a table."""
        if not issues:
            return "No issues found."

        rows = []
        for issue in issues[:20]:
            severity = issue.get("severity", "unknown")
            severity_emoji = {
                "high": "ðŸ”´",
                "medium": "ðŸŸ¡",
                "low": "ðŸŸ¢",
            }.get(severity, "âšª")

            file = issue.get("file", "Unknown")
            desc = issue.get("description", "")[:50]
            rows.append(f"| {severity_emoji} | {file} | {desc} |")

        header = "| Severity | File | Description |\n|----------|------|-------------|\n"
        return header + "\n".join(rows)

    def _format_todos(self, todos: List[Dict[str, Any]]) -> str:
        """Format TODOs as a list."""
        if not todos:
            return "No TODOs found."

        grouped = {}
        for todo in todos:
            ptype = todo.get("type", "todo")
            if ptype not in grouped:
                grouped[ptype] = []
            grouped[ptype].append(todo.get("description", "")[:80])

        sections = []
        for ptype, items in grouped.items():
            sections.append(f"### {ptype.upper()}\n" + "\n".join(f"- {i}" for i in items))

        return "\n\n".join(sections)
